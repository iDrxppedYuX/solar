<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar vi.alejandro</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.8rem; opacity: 0.7; }
        .label {
            position: absolute;
            background: rgba(0,0,0,0.6);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 10px;
            pointer-events: none;
            transform: translate(-50%, -150%);
            white-space: nowrap;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui">
        <h1>Solar System Viz</h1>
        <p>Left Click: Rotate | Right Click: Pan | Scroll: Zoom</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        // Note: Scales are exaggerated for visibility. 
        // In reality, the sun is massive and planets are tiny dots far apart.
        const config = {
            sunSize: 10,
            orbitSpeedMultiplier: 0.5,
            planetScale: 1
        };

        // Planet Data (Relative size, distance, color, speed)
        const planetData = [
            { name: "Mercury", size: 1.2, dist: 20, color: 0xA5A5A5, speed: 0.04 },
            { name: "Venus", size: 1.8, dist: 30, color: 0xE3BB76, speed: 0.015 },
            { name: "Earth", size: 2.0, dist: 45, color: 0x2233FF, speed: 0.01 },
            { name: "Mars", size: 1.4, dist: 60, color: 0xFF3300, speed: 0.008 },
            { name: "Jupiter", size: 5.0, dist: 90, color: 0xDCA768, speed: 0.002 },
            { name: "Saturn", size: 4.5, dist: 120, color: 0xC5AB6E, speed: 0.0009, hasRing: true },
            { name: "Uranus", size: 3.0, dist: 150, color: 0x4FD0E7, speed: 0.0004 },
            { name: "Neptune", size: 3.0, dist: 170, color: 0x2933CC, speed: 0.0001 }
        ];

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-50, 90, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lighting ---
        // Ambient light (soft general light)
        const ambientLight = new THREE.AmbientLight(0x333333); 
        scene.add(ambientLight);

        // Point light (The Sun)
        const pointLight = new THREE.PointLight(0xFFFFFF, 2, 400);
        scene.add(pointLight);

        // --- Objects ---

        // 1. The Sun
        const sunGeo = new THREE.SphereGeometry(config.sunSize, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFDD00 }); // Basic material ignores shadows/light (it glows)
        const sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        // 2. Starfield Background
        function createStars() {
            const starsGeo = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) {
                positions[i] = (Math.random() - 0.5) * 800; // Spread stars wide
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starsMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5});
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);
        }
        createStars();

        // 3. Planets
        const planets = []; // Store references for animation

        planetData.forEach(data => {
            // A. The Orbit System (Invisible Pivot)
            // We create an empty object at the center (Sun) for the planet to rotate around
            const orbitPivot = new THREE.Object3D();
            scene.add(orbitPivot);

            // B. The Planet Mesh
            const geometry = new THREE.SphereGeometry(data.size * config.planetScale, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: data.color,
                roughness: 0.7,
                metalness: 0.1
            });
            const planet = new THREE.Mesh(geometry, material);
            
            // Offset the planet from the pivot by its distance
            planet.position.x = data.dist;
            orbitPivot.add(planet);

            // C. Orbit Path (Visual Ring)
            const pathGeo = new THREE.RingGeometry(data.dist - 0.1, data.dist + 0.1, 64);
            const pathMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, opacity: 0.1, transparent: true });
            const path = new THREE.Mesh(pathGeo, pathMat);
            path.rotation.x = Math.PI / 2; // Lay flat
            scene.add(path);

            // D. Saturn's Rings (Special Case)
            if (data.hasRing) {
                const ringGeo = new THREE.RingGeometry(data.size * 1.4, data.size * 2.2, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xAABBCC, side: THREE.DoubleSide, opacity: 0.6, transparent: true });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2.2; // Slight tilt
                planet.add(ring);
            }

            // Store data for animation
            planets.push({
                mesh: planet,
                pivot: orbitPivot,
                speed: data.speed * config.orbitSpeedMultiplier,
                name: data.name
            });
        });

        // --- UI Labels (2D Overlay logic) ---
        // Simple implementation: Create DOM elements for planets
        const labelContainer = document.body;
        planets.forEach(p => {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = p.name;
            labelContainer.appendChild(div);
            p.label = div;
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Rotate Sun
            sun.rotation.y += 0.002;

            // Rotate Planets
            planets.forEach(p => {
                // Orbit around sun
                p.pivot.rotation.y += p.speed;
                
                // Self rotation
                p.mesh.rotation.y += 0.02;

                // Update Label Position
                // 1. Get planet world position
                const worldPos = new THREE.Vector3();
                p.mesh.getWorldPosition(worldPos);
                
                // 2. Project to 2D screen space
                worldPos.project(camera);

                const x = (worldPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(worldPos.y * 0.5) + 0.5) * window.innerHeight;

                // 3. Apply to CSS
                p.label.style.transform = `translate(-50%, -150%) translate(${x}px, ${y}px)`;
                
                // 4. Hide if behind the camera or too far (simple clipping)
                if (Math.abs(worldPos.z) > 1) {
                   p.label.style.opacity = 0;
                } else {
                   p.label.style.opacity = 1;
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
